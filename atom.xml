<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zb&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-05-06T13:33:21.017Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>zb</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker使用/镜像制作</title>
    <link href="http://example.com/2025/05/06/Docker%E4%BD%BF%E7%94%A8-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"/>
    <id>http://example.com/2025/05/06/Docker%E4%BD%BF%E7%94%A8-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/</id>
    <published>2025-05-06T13:23:43.000Z</published>
    <updated>2025-05-06T13:33:21.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Docker基础"><a href="#1-Docker基础" class="headerlink" title="1.Docker基础"></a>1.Docker基础</h1><h2 id="1-1-Docker-介绍"><a href="#1-1-Docker-介绍" class="headerlink" title="1.1 Docker 介绍"></a>1.1 Docker 介绍</h2><h3 id="Docker解决了什么？"><a href="#Docker解决了什么？" class="headerlink" title="Docker解决了什么？"></a>Docker解决了什么？</h3><h4 id="在别的电脑上不能跑的问题："><a href="#在别的电脑上不能跑的问题：" class="headerlink" title="在别的电脑上不能跑的问题："></a>在别的电脑上不能跑的问题：</h4><p>开发者经常遇到项目在自己的机器上能跑，部署到服务器上就出问题。Docker把运行环境也打包进去，确保“哪里都能跑”。</p><h4 id="环境配置繁琐"><a href="#环境配置繁琐" class="headerlink" title="环境配置繁琐"></a>环境配置繁琐</h4><p>安装依赖、配置系统库等工作复杂、容易出错。Docker一次配置好，别人直接使用镜像就可以。</p><h4 id="版本冲突问题"><a href="#版本冲突问题" class="headerlink" title="版本冲突问题"></a>版本冲突问题</h4><p>比如两个项目用不同版本的Python、MySQL，传统的方式难以共存，Docker可以让它们分别在不同的容器里运行，互不影响。</p><h4 id="开发、测试、部署一致性"><a href="#开发、测试、部署一致性" class="headerlink" title="开发、测试、部署一致性"></a>开发、测试、部署一致性</h4><p>Docker可以让开发环境、测试环境、线上环境完全一致，大大减少线上bug。</p><h4 id="跨平台部署"><a href="#跨平台部署" class="headerlink" title="跨平台部署"></a>跨平台部署</h4><p>Docker镜像支持构建一次，到处运行，跨平台部署变简单。</p><h3 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么?"></a>Docker是什么?</h3><p>Docker 是一个开源的应用容器引擎，基于 Go 语言，并遵从 Apache2.0 协议开源。它可以让开发者打包应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 、windows等机器上，也可以实现虚拟化。Docker 可用于开发应用、交付应用、运行应用等场景。<br>容器是完全使用沙箱机制，相互之间不会有任何接口，更重要的是容器性能开销极低。Docker 允许用户将基础设施中的应用单独分割出来，形成更小的部分容器，从而提高软件交付速度。</p><h3 id="Docker与虚拟机对比"><a href="#Docker与虚拟机对比" class="headerlink" title="Docker与虚拟机对比"></a>Docker与虚拟机对比</h3><p><strong>如果物理机是一栋住宅楼，虚拟机就是大楼中的一个个套间，而容器技术就是套间里的一个个隔断。</strong></p><h4 id="虚拟化技术不同"><a href="#虚拟化技术不同" class="headerlink" title="虚拟化技术不同"></a>虚拟化技术不同</h4><ul><li><p>VMware Workstation, VirtualBoX </p><p>硬件辅助虚拟化: 是指通过硬件辅助支持模拟运行环境，使客户机操作系统可以独立运行，实现完全虚拟化的功能。</p></li><li><p>Docker</p><p>操作系统层虚拟化: 这种技术将操作系统内核虚拟化，可以允许使用者空间软件实例被分割成几个独立单元，在内核中运行，而不是只有一个单一实例运行。软件实例，也被称为是一个容器、虚拟引擎、虚拟专用服务器。每个容器的进程是独立的，对使用者来说，就像是在使用自己的专用服务器。</p></li></ul><h4 id="应用场景不同"><a href="#应用场景不同" class="headerlink" title="应用场景不同"></a>应用场景不同</h4><ul><li>虚拟机更擅长于彻底隔离整个运行环境。如：云服务提供商通常采用虚拟机技术隔离不同的用户。</li><li>Docker通常用与隔离不同的应用，例如前端、后端以及数据库。</li></ul><h4 id="资源的使用率不同"><a href="#资源的使用率不同" class="headerlink" title="资源的使用率不同"></a>资源的使用率不同</h4><ul><li>虚拟机启动需要数分钟，而Docker容器可以数毫秒内启动。由于没有臃肿的操作系统，Docker可以节省大量的系统资源。</li></ul><h2 id="1-2-Docker架构与核心组件"><a href="#1-2-Docker架构与核心组件" class="headerlink" title="1.2 Docker架构与核心组件"></a>1.2 Docker架构与核心组件</h2><img src="../images/Docker使用-镜像制作/IMG_0774-1746538036557-2.JPG" alt="IMG_0774" style="zoom:150%;" /><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ul><li>linux终端</li></ul><p>通过终端，操作一些docker命令，完成对docker的操作</p><h4 id="docker服务器"><a href="#docker服务器" class="headerlink" title="docker服务器"></a>docker服务器</h4><ul><li>是一个守护进程，不能和用户交互，在后台运行</li><li>管理容器和镜像</li></ul><h4 id="docker镜像"><a href="#docker镜像" class="headerlink" title="docker镜像"></a>docker镜像</h4><ul><li>理解为一个可执行程序</li><li>镜像可以启动，启动之后就是容器</li><li>镜像一般不需要使用者制作</li></ul><h4 id="docker容器"><a href="#docker容器" class="headerlink" title="docker容器"></a>docker容器</h4><ul><li>占用内存、cpu资源</li><li>镜像可以启动，启动之后就是容器</li></ul><h4 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h4><ul><li>docker官方提供了一个镜像仓库 docker hub</li></ul><h1 id="2-Docker镜像管理"><a href="#2-Docker镜像管理" class="headerlink" title="2.Docker镜像管理"></a>2.Docker镜像管理</h1><img src="../images/Docker使用-镜像制作/IMG_0788-1746538101507-7.JPG" alt="IMG_0788" style="zoom:80%;" /><h2 id="2-1-镜像的搜索-获取-查看"><a href="#2-1-镜像的搜索-获取-查看" class="headerlink" title="2.1 镜像的搜索&#x2F;获取&#x2F;查看"></a>2.1 镜像的搜索&#x2F;获取&#x2F;查看</h2><h3 id="镜像搜索"><a href="#镜像搜索" class="headerlink" title="镜像搜索"></a>镜像搜索</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#命令</span></span><br><span class="line">$ docker search 镜像的名字</span><br><span class="line"><span class="comment">#字段关键字</span></span><br><span class="line">STARS  -  下载量</span><br><span class="line">OFFICIAL  -  是否官方出品</span><br><span class="line">AUTOMATED  -  是否自动化编译(通过dockerfile制作)</span><br></pre></td></tr></table></figure><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下载远程仓库(如Docker hub)中的镜像</span></span><br><span class="line">$ docker pull 镜像名</span><br><span class="line"><span class="comment">#镜像存储目录</span></span><br><span class="line"> /var/lib/docker/image</span><br></pre></td></tr></table></figure><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#命令</span></span><br><span class="line"><span class="comment">#查看所有镜像</span></span><br><span class="line">$ docker images</span><br><span class="line">$ docker image <span class="built_in">ls</span> </span><br><span class="line"><span class="comment">#查看特定镜像</span></span><br><span class="line">$ docker image 镜像的名字</span><br></pre></td></tr></table></figure><h2 id="2-2-镜像别名-删除"><a href="#2-2-镜像别名-删除" class="headerlink" title="2.2 镜像别名&#x2F;删除"></a>2.2 镜像别名&#x2F;删除</h2><h3 id="镜像别名"><a href="#镜像别名" class="headerlink" title="镜像别名"></a>镜像别名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span><br><span class="line"><span class="comment">#镜像ID不改变</span></span><br></pre></td></tr></table></figure><h3 id="镜像删除"><a href="#镜像删除" class="headerlink" title="镜像删除"></a>镜像删除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:$ docker rmi 镜像名字/镜像ID</span><br><span class="line"><span class="comment">#如果镜像有别名，必须根据名字:tag(如果tag不是latest,如果是则可以省略)</span></span><br><span class="line"><span class="comment">#没有别名，可以 名字/ID 删除</span></span><br></pre></td></tr></table></figure><h3 id="镜像的导入导出"><a href="#镜像的导入导出" class="headerlink" title="镜像的导入导出"></a>镜像的导入导出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line">- OPTIONS:</span><br><span class="line">  -o,--output string</span><br><span class="line">  导出的文件名</span><br><span class="line">- IMAGE</span><br><span class="line">本地镜像仓库中的镜像名 </span><br><span class="line"></span><br><span class="line">$ docker load [OPTIONS]</span><br><span class="line">-i,--input string</span><br><span class="line">string:通过save导出之后的文件名</span><br><span class="line">$ docker load &lt; string</span><br></pre></td></tr></table></figure><img src="/home/zb/下载/IMG_0788.JPG" alt="IMG_0788" style="zoom:80%;" /><h1 id="3-Docker容器管理"><a href="#3-Docker容器管理" class="headerlink" title="3.Docker容器管理"></a>3.Docker容器管理</h1><p><img src="/../images/Docker%E4%BD%BF%E7%94%A8-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/IMG_0798-1746538123497-9.JPG" alt="IMG_0798"></p><p>docker将镜像文件启动，得到一个容器，一个容器可以被看做一个操作系统</p><h2 id="3-1-容器的查看-创建-启动"><a href="#3-1-容器的查看-创建-启动" class="headerlink" title="3.1 容器的查看&#x2F;创建&#x2F;启动"></a>3.1 容器的查看&#x2F;创建&#x2F;启动</h2><ul><li>容器查看</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#命令</span></span><br><span class="line">$ docker ps</span><br><span class="line"><span class="comment">#关键字</span></span><br><span class="line">COMMAND:启动之后默认执行的第一个命令</span><br><span class="line">PORTS:容器和宿主机对应的映射端口</span><br></pre></td></tr></table></figure><ul><li>容器创建</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#容器被创建，但是还不能使用，需要启动</span></span><br><span class="line">$ docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">- OPTIONS:</span><br><span class="line">-i,--interactive:创建的容器是否关联标准输入</span><br><span class="line">-t,--<span class="built_in">tty</span>:是否给这个容器分配终端</span><br><span class="line">--<span class="built_in">rm</span>:容器停止后是否自动销毁</span><br><span class="line">--name:给容器的名字，没指定随机生成</span><br><span class="line">- IMAGE: 基于哪个镜像启动</span><br><span class="line">- [COMMAND] [ARG...]</span><br><span class="line">容器启动之后，指定一个默认执行的shell命令，根据实际情况指定</span><br></pre></td></tr></table></figure><ul><li>创建新容器并启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建并运行容器run == create + start</span></span><br><span class="line">$ docker run [OPTIONS] IMAGE [COMMAND] [ARGS...]</span><br><span class="line">- OPTIONS:</span><br><span class="line">-i,--interactive:  </span><br><span class="line">-t,--<span class="built_in">tty</span>:</span><br><span class="line">--<span class="built_in">rm</span>:</span><br><span class="line">--name:</span><br><span class="line">-d,--detach:容器启动后是否为守护进程(后台运行)</span><br><span class="line">- IMAGE:</span><br><span class="line">- [COMMAND] [ARG...]</span><br><span class="line">容器启动之后，指定一个默认执行的shell命令，根据实际情况指定</span><br></pre></td></tr></table></figure><h2 id="3-2-容器的暂停-重启"><a href="#3-2-容器的暂停-重启" class="headerlink" title="3.2 容器的暂停&#x2F;重启"></a>3.2 容器的暂停&#x2F;重启</h2><ul><li>暂停</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pause 容器名/容器ID</span><br></pre></td></tr></table></figure><ul><li>取消暂停</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker unpause 容器名/容器ID</span><br></pre></td></tr></table></figure><ul><li>重启</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker restart 容器名/容器ID</span><br></pre></td></tr></table></figure><h2 id="3-3-容器的关闭-终止-删除"><a href="#3-3-容器的关闭-终止-删除" class="headerlink" title="3.3 容器的关闭&#x2F;终止&#x2F;删除"></a>3.3 容器的关闭&#x2F;终止&#x2F;删除</h2><ul><li>关闭</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#延时关闭，默认10s</span></span><br><span class="line">$ docker stop 容器名/容器ID</span><br><span class="line">-t,--<span class="keyword">time</span>:指定时长后关闭   </span><br></pre></td></tr></table></figure><ul><li>终止</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#立刻关闭，不会延时</span></span><br><span class="line">$ docker <span class="built_in">kill</span> 容器名/容器ID</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">rm</span> 容器名/容器ID</span><br><span class="line">-f,--force:  可删除正在运行的容器</span><br><span class="line"><span class="comment">#批量删除容器</span></span><br><span class="line">$ docker <span class="built_in">rm</span> -f $(docker ps -aq)</span><br></pre></td></tr></table></figure><h2 id="3-4-容器的进入-查看"><a href="#3-4-容器的进入-查看" class="headerlink" title="3.4 容器的进入&#x2F;查看"></a>3.4 容器的进入&#x2F;查看</h2><ul><li>进入容器</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> 参数 容器名 bash</span><br><span class="line">-i:关联标准输入</span><br><span class="line">-t:分配一个操作终端</span><br></pre></td></tr></table></figure><ul><li>查看容器的详细信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect 容器名/容器ID</span><br></pre></td></tr></table></figure><ul><li>查看容器的端口信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker port 容器名/容器ID</span><br></pre></td></tr></table></figure><p><img src="/home/zb/%E4%B8%8B%E8%BD%BD/IMG_0798.JPG" alt="IMG_0798"></p><h1 id="4-Docker数据管理"><a href="#4-Docker数据管理" class="headerlink" title="4.Docker数据管理"></a>4.Docker数据管理</h1><h2 id="4-0-数据拷贝"><a href="#4-0-数据拷贝" class="headerlink" title="4.0 数据拷贝"></a>4.0 数据拷贝</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#容器和宿主机之间的数据拷贝</span></span><br><span class="line">$ docker <span class="built_in">cp</span> 宿主机目录/文件 容器/容器ID:容器路径</span><br><span class="line">$ docker <span class="built_in">cp</span> 容器/容器ID:容器目录/文件 宿主路径</span><br></pre></td></tr></table></figure><h2 id="4-1-数据卷和使用"><a href="#4-1-数据卷和使用" class="headerlink" title="4.1 数据卷和使用"></a>4.1 数据卷和使用</h2><h3 id="数据卷是什么"><a href="#数据卷是什么" class="headerlink" title="数据卷是什么"></a>数据卷是什么</h3><p>宿主机的存储目录，要将目录中的数据和docker容器进行数据共享</p><h3 id="数据卷在docker中的应用"><a href="#数据卷在docker中的应用" class="headerlink" title="数据卷在docker中的应用"></a>数据卷在docker中的应用</h3><h4 id="挂载目录"><a href="#挂载目录" class="headerlink" title="挂载目录"></a>挂载目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#挂载的时机:</span></span><br><span class="line"><span class="comment">#1.容器被创建的时候 </span></span><br><span class="line">$ docker create</span><br><span class="line"><span class="comment">#2.容器被创建并运行的时候</span></span><br><span class="line">$ docker run</span><br><span class="line"><span class="comment">#添加需要挂载的卷</span></span><br><span class="line">-v,--volume</span><br><span class="line"></span><br><span class="line"><span class="comment">#形成映射关系</span></span><br><span class="line">$ docker run -itd --name -v 宿主机的路径:容器的路径 <span class="built_in">test</span> ubuntu bash</span><br><span class="line">-宿主机的路径:必须使用绝对路径，如果宿主机器路径不存在，会自动创建</span><br><span class="line">-容器的路径：如果不存在会被自动创建</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h4><p>通过-v进行数据卷挂载，默认是读写的挂载方式</p><ul><li>权限是限制容器的，rw</li><li>可以修改权限，改为只读:ro</li></ul><p><code>$ docker run -itd --name -v 宿主机的路径:容器的路径:ro  test ubuntu bash</code></p><h2 id="4-2-数据卷容器和使用"><a href="#4-2-数据卷容器和使用" class="headerlink" title="4.2 数据卷容器和使用"></a>4.2 数据卷容器和使用</h2><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p>就是一个普通的容器，在这个容器中提供了<strong>一个挂载目录(共享目录)</strong></p><ul><li>&#x2F;数据卷容器只要被创建出来就可以使用:<code> docker create</code>、<code>docker run</code></li></ul><h3 id="创建数据卷容器"><a href="#创建数据卷容器" class="headerlink" title="创建数据卷容器"></a>创建数据卷容器</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker create -itd --name 容器名 -v 容器的挂载目录 镜像名 shell命令</span><br><span class="line">docker run  -itd --name 容器名 -v 容器的挂载目录 镜像名 shell命令</span><br><span class="line">- 容器的挂载目录: 如果不存在，就会自动创建</span><br></pre></td></tr></table></figure><h3 id="数据卷容器的挂载使用"><a href="#数据卷容器的挂载使用" class="headerlink" title="数据卷容器的挂载使用"></a>数据卷容器的挂载使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#挂载数据卷容器的参数</span></span><br><span class="line">--volumes-from 数据卷容器的名字/ID</span><br><span class="line"><span class="comment">#1.创建数据卷容器</span></span><br><span class="line">docker run -itd --name containsVolume -v /volume ubuntu bash</span><br><span class="line"><span class="comment">#2.启动测试容器1,挂载数据卷容器</span></span><br><span class="line">docker run -itd --name test1 --volumes-from containsVolume ubuntu bash</span><br><span class="line"><span class="comment">#3.启动测试容器2,挂载数据卷容器</span></span><br><span class="line">docker run -itd --name test2 --volumes-from containsVolume ubuntu bash</span><br><span class="line"><span class="comment">#4.测试数据是否共享</span></span><br><span class="line">docker <span class="built_in">exec</span> -it test1 bash</span><br></pre></td></tr></table></figure><h3 id="数据卷容器数据卷备份"><a href="#数据卷容器数据卷备份" class="headerlink" title="数据卷容器数据卷备份"></a>数据卷容器数据卷备份</h3><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个临时新容器，挂载到数据卷容器上，并且和宿主机目录形成映射关系</span></span><br><span class="line">docker run -itd --<span class="built_in">rm</span> --name backup --volumes-from containsVolume -v /home/backup:/xxx  \</span><br><span class="line"><span class="comment">#将volume中的内容拷贝到xxx目录</span></span><br><span class="line">ubuntu <span class="built_in">cp</span> /volume /xxx -r</span><br><span class="line"><span class="comment">#或者压缩</span></span><br><span class="line">ubuntu tar zcvf /xxx/backup.tar.gz /volume</span><br></pre></td></tr></table></figure><h4 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个临时新容器，挂载到数据卷容器上，并且和宿主机目录形成映射关系</span></span><br><span class="line">docker run -itd --<span class="built_in">rm</span> --name backup --volumes-from containsVolume -v /home/backup:/xxx  \</span><br><span class="line"><span class="comment">#将xxx目录拷贝到volume目录</span></span><br><span class="line">ubuntu <span class="built_in">cp</span> /xxx /volume -r</span><br><span class="line"><span class="comment">#或者解压缩</span></span><br><span class="line">ubuntu tar zxpf /xxx/backup.tar.gz -C /</span><br></pre></td></tr></table></figure><h1 id="5-Docker网络管理"><a href="#5-Docker网络管理" class="headerlink" title="5.Docker网络管理"></a>5.Docker网络管理</h1><h2 id="5-1-docker端口映射"><a href="#5-1-docker端口映射" class="headerlink" title="5.1 docker端口映射"></a>5.1 docker端口映射</h2><h3 id="随机端口映射"><a href="#随机端口映射" class="headerlink" title="随机端口映射"></a>随机端口映射</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建容器时启动端口映射</span></span><br><span class="line">docker run -itd -P --name mynginx nginx </span><br><span class="line"><span class="comment">#在宿主机随便找一个没有占用的空闲端口和容器的80端口进行映射</span></span><br></pre></td></tr></table></figure><h3 id="指定端口映射-指定多端口映射"><a href="#指定端口映射-指定多端口映射" class="headerlink" title="指定端口映射&#x2F;指定多端口映射"></a>指定端口映射&#x2F;指定多端口映射</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用的参数</span></span><br><span class="line">docker run -itd -p xxx --name mynginx nginx</span><br><span class="line">-p 宿主机的IP:宿主机的端口:容器的端口</span><br><span class="line">   宿主机的端口:容器的端口</span><br><span class="line"><span class="comment">#指定多个端口映射</span></span><br><span class="line">docker run -itd -p 8080:80 -p 8081:81 --name mynginx nginx</span><br></pre></td></tr></table></figure><h2 id="5-2-网络管理"><a href="#5-2-网络管理" class="headerlink" title="5.2 网络管理"></a>5.2 网络管理</h2><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果多个容器想进行通信，那么这些容器必须要在同一个网络中</span></span><br><span class="line">$ docker network --<span class="built_in">help</span></span><br><span class="line">Usage:  docker network COMMAND</span><br><span class="line"></span><br><span class="line">Manage networks</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  connect     把一个容器加入到一个网络中</span><br><span class="line">  create      创建一个网络</span><br><span class="line">  disconnect  将一个容器从网络中移出</span><br><span class="line">  inspect     查看网络细节</span><br><span class="line">  <span class="built_in">ls</span>          列出网络</span><br><span class="line">  prune       移除所有不用的网络</span><br><span class="line">  <span class="built_in">rm</span>          移除指定网络 </span><br><span class="line">  </span><br><span class="line">$ docker network <span class="built_in">ls</span></span><br><span class="line">NETWORK ID     NAME                  DRIVER    SCOPE</span><br><span class="line">5854ecbd3fd7   bridge                bridge    <span class="built_in">local</span></span><br><span class="line">25d01b5a58fd   host                  host      <span class="built_in">local</span></span><br><span class="line">e6ba185fe6c9   none                  null      <span class="built_in">local</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="bridge网络模式"><a href="#bridge网络模式" class="headerlink" title="bridge网络模式"></a>bridge网络模式</h3><p>独立的网络栈，独立的IP，外部访问需要端口映射</p><h4 id="创建bridge网络"><a href="#创建bridge网络" class="headerlink" title="创建bridge网络"></a>创建bridge网络</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d 网络驱动的名字 要创建的网络的名字</span><br></pre></td></tr></table></figure><h4 id="自定义网段与网关"><a href="#自定义网段与网关" class="headerlink" title="自定义网段与网关"></a>自定义网段与网关</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--subnet:指定子网络的网段</span><br><span class="line">--gateway:指定网关</span><br><span class="line">$ docker network create -d bridge --subnet 180.18.10.0/24 --gateway 180.18.10.1</span><br></pre></td></tr></table></figure><h4 id="在自定义网路中启动容器"><a href="#在自定义网路中启动容器" class="headerlink" title="在自定义网路中启动容器"></a>在自定义网路中启动容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name test3 --network 自定义网络名字 ubuntu bash</span><br><span class="line">--network:指定要加入的网络</span><br></pre></td></tr></table></figure><h4 id="容器断开-连接网络"><a href="#容器断开-连接网络" class="headerlink" title="容器断开&#x2F;连接网络"></a>容器断开&#x2F;连接网络</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#断开网络</span></span><br><span class="line">docker network disconnect [OPTIONS] 网络名 容器名</span><br><span class="line">-OPTIONS:</span><br><span class="line">-f:强制执行</span><br><span class="line"><span class="comment">#连接网络 </span></span><br><span class="line">docker network connect 网络名 容器名</span><br></pre></td></tr></table></figure><h3 id="host网络模式"><a href="#host网络模式" class="headerlink" title="host网络模式"></a>host网络模式</h3><p><strong>容器直接使用宿主机的网络栈</strong>，不需要端口映射，无网络开销</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -itd --name test4 --network host ubuntu bash</span><br><span class="line">--network host</span><br></pre></td></tr></table></figure><h1 id="6-Dockerfile"><a href="#6-Dockerfile" class="headerlink" title="6.Dockerfile"></a>6.Dockerfile</h1><h2 id="6-1-dockerfile介绍"><a href="#6-1-dockerfile介绍" class="headerlink" title="6.1 dockerfile介绍"></a>6.1 dockerfile介绍</h2><p> 按照文件的规则构建镜像，告诉Docker怎么一步步做出自己想要的镜像</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#构建一个基于ubuntu的docker定制镜像</span></span><br><span class="line"><span class="comment">#基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> hello</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> world</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; apt install -y nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#声明暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>宿主机创建一个空目录，将上边的dockerfile文件放到里边</li><li>在dockerfile对应的目录中执行一个命令，构建新的镜像</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t mynginx:v1.0 dockerfile所在的目录(./)</span><br><span class="line">-t,--tag:指定构建出的镜像名字和版本</span><br></pre></td></tr></table></figure><h2 id="6-2-dockerfile关键字"><a href="#6-2-dockerfile关键字" class="headerlink" title="6.2 dockerfile关键字"></a>6.2 dockerfile关键字</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> 镜像名</span><br><span class="line"><span class="keyword">FROM</span> 镜像名:TAG</span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="comment">#FROM必须要出现在第一行(除注释)，可以多次FROM</span></span><br><span class="line"><span class="comment">#如果本地和远程仓库都不存在，报错</span></span><br><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">FROM</span> redis</span><br></pre></td></tr></table></figure><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MAINTAINER</span> 维护人员信息</span><br></pre></td></tr></table></figure><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#构建镜像时执行的shell命令，如果命令有确认操作，必须加-y</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> shell命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; apt install -y nginx</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> g++ xxx -o out</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;mkdir&quot;</span>,<span class="string">&quot;/home/test&quot;</span>,<span class="string">&quot;-p&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置对外开放的端口</span></span><br><span class="line"><span class="comment">#让宿主机和容器开放端口形成一个映射关系，就可以访问了</span></span><br><span class="line"><span class="comment"># docker run -itd -p 8888:80</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h2 id="6-3-dockerfile运行时指令"><a href="#6-3-dockerfile运行时指令" class="headerlink" title="6.3 dockerfile运行时指令"></a>6.3 dockerfile运行时指令</h2><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#容器启动后默认执行的命令</span></span><br><span class="line"><span class="comment">#改命令会被docker run指定的shell命令覆盖</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> shell命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;shell命令&quot;</span>,<span class="string">&quot;参数1&quot;</span>,<span class="string">&quot;参数2&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#与CMD一样</span></span><br><span class="line"><span class="comment">#但是不会被docker run 指定的shell命令覆盖</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> shell命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;shell命令&quot;</span>,<span class="string">&quot;参数1&quot;</span>,<span class="string">&quot;参数2&quot;</span>]</span></span><br></pre></td></tr></table></figure><h2 id="6-4-dockerfile文件编辑指令"><a href="#6-4-dockerfile文件编辑指令" class="headerlink" title="6.4 dockerfile文件编辑指令"></a>6.4 dockerfile文件编辑指令</h2><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将宿主机文件拷贝到镜像目录中</span></span><br><span class="line"><span class="comment">#如果是压缩包则进行解压缩</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> [<span class="string">&quot;宿主机文件&quot;</span>,<span class="string">&quot;镜像目录/文件&quot;</span>]</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> [<span class="string">&quot;./a.txt&quot;</span>,<span class="string">&quot;/home/test/a.txt&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#与ADD类似，只是不会自动解压</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [<span class="string">&quot;./a.tar.gz&quot;</span>,<span class="string">&quot;/home/&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建数据卷容器</span></span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -itd --name containsVolume -v /volume ubuntu bash</span></span><br><span class="line"><span class="comment">#测试容器挂载数据卷容器</span></span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -itd --name test1 --volumes-from containsVolume ubuntu bash</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#VOLUME指令可以在镜像中声明挂载，这样只要通过该镜像创建的容器都有了挂载点</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;/data&quot;</span>]</span></span><br></pre></td></tr></table></figure><h2 id="6-5-dockerfile环境指令"><a href="#6-5-dockerfile环境指令" class="headerlink" title="6.5 dockerfile环境指令"></a>6.5 dockerfile环境指令</h2><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置环境变量， 可以在RUN之前使用，然后RUN命令时调用</span></span><br><span class="line"><span class="comment">#容器启动时这些环境变量都会被指定</span></span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> HELLO <span class="number">12345</span></span><br><span class="line"><span class="keyword">ENV</span> HELLO=<span class="number">12345</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /home/a/b/c/d/e/f/.../z</span></span><br><span class="line"><span class="keyword">ENV</span> MYPATH=/a/b/c/d/e/.../z</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /home <span class="variable">$MYPATH</span></span></span><br></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#切换目录，为后续的RUN、CMD、ENTRYPOINT 指令配置工作目录。相当于cd</span></span><br><span class="line"><span class="comment">#可以多次切换</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /path/to/work</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> a.sh</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /path</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> to  <span class="comment">#相对路径(cd to)</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> workdir</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/path/to/<span class="keyword">workdir</span></span><br></pre></td></tr></table></figure><h1 id="7-docker-compose"><a href="#7-docker-compose" class="headerlink" title="7.docker-compose"></a>7.docker-compose</h1><p>Compose是Docker容器进行编排的工具，定义和运行多容器应用，可以一条命令启动多个容器，使用Docker  Compose不再需要使用shell脚本来启动容器。</p><p>Compose通过一个配置文件来管理多个Docker容器，在配置文件中，所有的容器通过services来定义，然后使用<strong>docker-compose脚本</strong>来启动，停止和重启应用，和应用中的服务以及所有依赖服务的容器，非常适合组合使用多个容器进行开发的场景。</p><p>配置文件默认名字: docker-compose.yaml&#x2F;yml</p><h2 id="7-0-yaml文件格式"><a href="#7-0-yaml文件格式" class="headerlink" title="7.0 yaml文件格式"></a>7.0 yaml文件格式</h2><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>不能使用tab建缩进，<strong>只能使用空格键</strong></li><li>缩进长度没有限制，只要对齐就表示这些元素属于一个层级</li><li>字符串可以不用引号标注</li></ul><h2 id="7-1-docker-compose配置文件"><a href="#7-1-docker-compose配置文件" class="headerlink" title="7.1 docker-compose配置文件"></a>7.1 docker-compose配置文件</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span><span class="comment">#docker-compose 的版本</span></span><br><span class="line"><span class="attr">services:</span><span class="comment">#服务</span></span><br><span class="line"><span class="attr">web:</span><span class="comment">#服务名，自己起的，每个服务名对应一个启动的容器</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line"><span class="attr">container_name:</span> <span class="string">myweb</span></span><br><span class="line"><span class="attr">ports:</span><span class="comment">#向外开放的端口</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;3000&quot;</span> <span class="comment">#3000是容器对外开放的端口，宿主机随即分配一个与3000映射</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">front-tier</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">back-tier</span></span><br><span class="line"><span class="attr">enviroment:</span><span class="comment">#环境变量</span></span><br><span class="line"><span class="attr">RACK_ENV:</span> <span class="string">development</span></span><br><span class="line"><span class="attr">SHOW:</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line"><span class="attr">command:</span>  <span class="string">tree</span> <span class="string">-L</span> <span class="number">3</span></span><br><span class="line"><span class="attr">extends:</span></span><br><span class="line"><span class="attr">file:</span> <span class="string">common.yml</span></span><br><span class="line"><span class="attr">service:</span> <span class="string">webapp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">web</span></span><br><span class="line"><span class="attr">newtworks:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">back-tier</span></span><br><span class="line"></span><br><span class="line"><span class="attr">lb:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">dockercloud/haproxy</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="string">-front-tier</span></span><br><span class="line"><span class="string">-back-tier</span></span><br><span class="line"><span class="comment">#挂载目录，相当于-v</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">/var/run/docker/sock:/var/run/docker.sock</span></span><br><span class="line"><span class="attr">depend_on:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">web</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">lb</span></span><br><span class="line"><span class="attr">networks:</span><span class="comment">#声明网络</span></span><br><span class="line"><span class="attr">front-tier:</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line"><span class="attr">back-tier:</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><h2 id="7-2-docker-compose-命令"><a href="#7-2-docker-compose-命令" class="headerlink" title="7.2 docker compose 命令"></a>7.2 docker compose 命令</h2><h3 id="compose-服务启动、关闭、查看"><a href="#compose-服务启动、关闭、查看" class="headerlink" title="compose 服务启动、关闭、查看"></a>compose 服务启动、关闭、查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">前置条件:docker-compose.ymal</span><br><span class="line"><span class="comment">#启动docker容器</span></span><br><span class="line">$ docker compose up -d</span><br><span class="line">-d: 以守护进程方式启动(后台运行)#不加会占用一个终端，用来输出启动过程中的日志信息</span><br><span class="line"><span class="comment">#如果配置文件不叫docker-compose.yaml,叫temp.yaml，则要指定配置文件</span></span><br><span class="line">$ docker compose -f temp.yaml up -d</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭，并删除容器</span></span><br><span class="line">$ docker compose down</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看启动的容器</span></span><br><span class="line">$ docker compose ps</span><br></pre></td></tr></table></figure><h3 id="容器开启、关闭、删除"><a href="#容器开启、关闭、删除" class="headerlink" title="容器开启、关闭、删除"></a>容器开启、关闭、删除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动某一个容器</span></span><br><span class="line">$ docker compose start 服务名</span><br><span class="line"></span><br><span class="line"><span class="comment">#容器的关闭，没有删除</span></span><br><span class="line">$ docker compose stop 服务名</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除</span></span><br><span class="line">$ docker compose <span class="built_in">rm</span> 服务名</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Docker基础&quot;&gt;&lt;a href=&quot;#1-Docker基础&quot; class=&quot;headerlink&quot; title=&quot;1.Docker基础&quot;&gt;&lt;/a&gt;1.Docker基础&lt;/h1&gt;&lt;h2 id=&quot;1-1-Docker-介绍&quot;&gt;&lt;a href=&quot;#1-1-Dock</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>云服务器防止被攻击(Ubuntu/Debian)</title>
    <link href="http://example.com/2025/04/23/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%B2%E6%AD%A2%E8%A2%AB%E6%94%BB%E5%87%BB-Ubuntu-Debian/"/>
    <id>http://example.com/2025/04/23/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%B2%E6%AD%A2%E8%A2%AB%E6%94%BB%E5%87%BB-Ubuntu-Debian/</id>
    <published>2025-04-23T13:30:40.000Z</published>
    <updated>2025-04-23T13:31:13.232Z</updated>
    
    <content type="html"><![CDATA[<p>最近云server部署不到一天就被暴力攻击了，甚至直接登录了root账户，还把我自己的本地ip封禁了，现在正好列举一些防止被网络攻击的方法</p><p>公网ip实属难得，有利有弊，一方面可以让自己非常快地连接server并且搭建网站，另一方面非常容易被坏人攻击</p><h2 id="SSH安全性加强"><a href="#SSH安全性加强" class="headerlink" title="SSH安全性加强"></a>SSH安全性加强</h2><h3 id="1-只允许密钥登录-非密码登录"><a href="#1-只允许密钥登录-非密码登录" class="headerlink" title="1.只允许密钥登录(非密码登录)"></a>1.只允许密钥登录(非密码登录)</h3><p>编辑SSH配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>找到并修改内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PasswordAuthentication no <span class="comment">#root密码登录</span></span><br><span class="line">PubkeyAuthentication <span class="built_in">yes</span>  <span class="comment">#ssh密钥登录</span></span><br></pre></td></tr></table></figure><p>重启SSH服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart ssh</span><br></pre></td></tr></table></figure><h3 id="2-修改默认SSH端口"><a href="#2-修改默认SSH端口" class="headerlink" title="2.修改默认SSH端口"></a>2.修改默认SSH端口</h3><p>讲默认的22端口改为不常见的端口(防止被扫)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sshd_config</span></span><br><span class="line">Port 22222 <span class="comment">#防火墙也要放行端口</span></span><br></pre></td></tr></table></figure><h2 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h2><p>启动并配置UWF防火墙</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw default deny incoming</span><br><span class="line"><span class="built_in">sudo</span> ufw default allow outgoing</span><br><span class="line"><span class="built_in">sudo</span> ufw allow OpenSSH  <span class="comment"># 或你自定义的 SSH 端口</span></span><br><span class="line"><span class="built_in">sudo</span> ufw allow http</span><br><span class="line"><span class="built_in">sudo</span> ufw allow https</span><br><span class="line"><span class="built_in">sudo</span> ufw <span class="built_in">enable</span></span><br></pre></td></tr></table></figure><h2 id="Fail2ban防爆破"><a href="#Fail2ban防爆破" class="headerlink" title="Fail2ban防爆破"></a>Fail2ban防爆破</h2><p>安装并启用Fail2ban</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install fail2ban</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> fail2ban</span><br><span class="line"><span class="built_in">sudo</span> systemctl start fail2ban</span><br></pre></td></tr></table></figure><p>可以屏蔽多次失败登录的IP,但自己不要故意去试，因为我已经试过了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近云server部署不到一天就被暴力攻击了，甚至直接登录了root账户，还把我自己的本地ip封禁了，现在正好列举一些防止被网络攻击的方法&lt;/p&gt;
&lt;p&gt;公网ip实属难得，有利有弊，一方面可以让自己非常快地连接server并且搭建网站，另一方面非常容易被坏人攻击&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++实现日志库</title>
    <link href="http://example.com/2025/04/19/C-%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E5%BA%93/"/>
    <id>http://example.com/2025/04/19/C-%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E5%BA%93/</id>
    <published>2025-04-19T03:50:17.000Z</published>
    <updated>2025-04-23T13:32:31.663Z</updated>
    
    <content type="html"><![CDATA[<p>调用日志库有两种高效的方式，基本思路是全局定义宏：这里使用第二种</p><ul><li>1.使用operator&lt;&lt;重载，将log信息当作流，类似于cout&lt;&lt;</li><li>2.使用函数调用，将log信息当作函数参数，类似于print()</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LOG_INFO&lt;&lt;<span class="string">&quot;服务器启动成功，端口：&quot;</span>&lt;&lt;port;</span><br><span class="line">LOG_WARN&lt;&lt;<span class="string">&quot;连接超时:&quot;</span>&lt;&lt;connId;</span><br><span class="line">LOG_ERROR&lt;&lt;<span class="string">&quot;数据库连接失败&quot;</span>；</span><br><span class="line"><span class="built_in">LOG_INFO</span>(<span class="string">&quot;服务器启动成功，端口：%d&quot;</span>,port);</span><br><span class="line"><span class="built_in">LOG_WARN</span>(<span class="string">&quot;连接超时: %d&quot;</span>,connId);</span><br><span class="line"><span class="built_in">LOG_ERROR</span>(<span class="string">&quot;数据库连接失败&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="日志库功能"><a href="#日志库功能" class="headerlink" title="日志库功能"></a>日志库功能</h2><p>日志库（Logging Library）是用于记录运行时信息的工具组件。</p><p><strong>作为server唯一输出的内容，日志库显得尤为重要</strong>。</p><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><ul><li><strong>日志级别</strong> : 支持不同级别（如 DEBUG、INFO、WARN、ERROR、FATAL），方便控制输出粒度。</li><li><strong>时间戳</strong>：每条日志通常包含精确的时间戳，帮助排查问题。</li><li><strong>线程信息</strong>: 可选地记录线程 ID。</li></ul><h3 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h3><p>日志库可以将日志信息输出到不同的目标，包括：</p><ul><li><strong>终端输出</strong>：打印到终端或命令行界面，用于开发和调试。</li><li><strong>文件输出</strong>：将日志写入文件中，持久存储在日志文件中。</li><li><strong>网络输出</strong>：通过网络将日志发送到远程服务器或日志收集系统。</li><li><strong>数据库</strong>：有些日志库允许将日志信息存储到数据库中。</li></ul><h3 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[2025-03-14 03:40:27][TRACE] updateChannel Poller.cc:49: fd=3 events=3</span><br><span class="line">[2025-03-14 03:40:27][TRACE] EventLoop EventLoop.cc:16: EventLoop created 0x7ffd65bb0120 <span class="keyword">in</span> thread 12521</span><br><span class="line">[2025-03-14 03:40:28][TRACE] poll Poller.cc:15: 1 events happended</span><br><span class="line">[2025-03-14 03:40:28][TRACE] readTimerfd TimerQueue.cc:60: TimerQueue::handleRead() reads 8 at 1745034028.327096</span><br></pre></td></tr></table></figure><h2 id="Logger类设计"><a href="#Logger类设计" class="headerlink" title="Logger类设计"></a>Logger类设计</h2><p>最基本的功能 log()，输出日志</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">LogLevel</span></span><br><span class="line">        &#123;</span><br><span class="line">            TRACE,</span><br><span class="line">            DEBUG,</span><br><span class="line">            INFO,</span><br><span class="line">            WARN,</span><br><span class="line">            ERROR,</span><br><span class="line">            FATAL,</span><br><span class="line">            NUM_LOG_LEVALS,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(SourceFile file, <span class="type">int</span> line, LogLevel level, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(SourceFilefile, <span class="type">int</span> line, LogLevel level, <span class="type">const</span> <span class="type">char</span> *func, <span class="type">const</span> <span class="type">char</span> *fmt...)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">logSys</span><span class="params">(SourceFile file, <span class="type">int</span> line, <span class="type">bool</span> fatal, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> LogLevel <span class="title">logLevel</span><span class="params">()</span></span>;<span class="comment">//设置日当前志级别</span></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setLogLevel</span><span class="params">(LogLevel level)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*OutputFunc)</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg, <span class="type">int</span> len)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FlushFunc)</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setOutput</span><span class="params">(OutputFunc)</span></span>;<span class="comment">//设置输出方式，自定义回调如输出到终端或者输出到文件</span></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setFlush</span><span class="params">(FlushFunc)</span></span>;<span class="comment">//设置刷新缓冲方式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">Logger</span>() = <span class="keyword">delete</span>;<span class="comment">//不允许实例化Logger类</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>配置的SouceFIle是一个小工具类，用于从__FILE__中提取文件名，避免日志中出现过长的路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SourceFile</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *data_;</span><br><span class="line">    <span class="type">int</span> size_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line">    <span class="built_in">SourceFile</span>(<span class="type">const</span> <span class="built_in">char</span> (&amp;arr)[N]) : <span class="built_in">data_</span>(arr), <span class="built_in">size_</span>(N - <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SourceFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename)</span> : data_(filename);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="日志输出逻辑"><a href="#日志输出逻辑" class="headerlink" title="日志输出逻辑"></a>日志输出逻辑</h2><p>我们重点实现的格式化日志调用方式是这样的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger::<span class="built_in">log</span>(__FILE__,__LINE__,Logger::INFO,fmt,...);</span><br></pre></td></tr></table></figure><h3 id="实现代码核心逻辑如下"><a href="#实现代码核心逻辑如下" class="headerlink" title="实现代码核心逻辑如下"></a>实现代码核心逻辑如下</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">formatTime</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (now != t_lastSecond)</span><br><span class="line">    &#123;</span><br><span class="line">        t_lastSecond = now;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">tm</span> tm_time;</span><br><span class="line">        <span class="built_in">gmtime_r</span>(&amp;now, &amp;tm_time);</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, size, <span class="string">&quot;%4d%02d%02d %02d:%02d:%02d&quot;</span>,</span><br><span class="line">                 tm_time.tm_year + <span class="number">1900</span>, tm_time.tm_mon + <span class="number">1</span>, tm_time.tm_mday,</span><br><span class="line">                 tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::log</span><span class="params">(SourceFile file, <span class="type">int</span> line, LogLevel level, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (level &lt; g_logLevel)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       std::string time_buf;</span><br><span class="line">       Timestamp timestamp = Timestamp::<span class="built_in">now</span>();</span><br><span class="line">       time_buf = timestamp.<span class="built_in">toFormattedString</span>(showMicroseconds);</span><br><span class="line"><span class="comment">/*初始化时间也可:</span></span><br><span class="line"><span class="comment">char timebuf[64];</span></span><br><span class="line"><span class="comment">formatTime(buf,sizeof(buf));</span></span><br><span class="line"><span class="comment">这里使用时间戳类避免再次实现*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//格式化用户传入的消息</span></span><br><span class="line">       <span class="type">char</span> msg_buf[<span class="number">1024</span>];</span><br><span class="line">       va_list args;</span><br><span class="line">       <span class="built_in">va_start</span>(args, fmt);</span><br><span class="line">       <span class="built_in">vsnprintf</span>(msg_buf, <span class="built_in">sizeof</span>(msg_buf), fmt, args);</span><br><span class="line">       <span class="built_in">va_end</span>(args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拼接最终输出内容</span></span><br><span class="line">       <span class="type">char</span> line_buf[<span class="number">2048</span>];</span><br><span class="line">       <span class="built_in">snprintf</span>(line_buf, <span class="built_in">sizeof</span>(line_buf), <span class="string">&quot;[%s][%s] %s:%d: %s\n&quot;</span>,</span><br><span class="line">                time_buf.<span class="built_in">c_str</span>(), levelNames[level], file.data_, line, msg_buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁输出日志</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">       <span class="built_in">g_output</span>(line_buf, <span class="built_in">strlen</span>(line_buf));</span><br><span class="line">       <span class="built_in">g_flush</span>();</span><br><span class="line">    <span class="comment">//如果是FATAL级别，终止程序</span></span><br><span class="line">       <span class="keyword">if</span> (level == FATAL)</span><br><span class="line">           <span class="built_in">abort</span>();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="日志宏封装"><a href="#日志宏封装" class="headerlink" title="日志宏封装"></a>日志宏封装</h2><p>使用宏是为了让调用更简洁，自动传入__FILE__和__LINE__,日志级别等元信息:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(fmt, ...) \</span></span><br><span class="line"><span class="meta">    Logger::log(Logger::SourceFile(__FILE__), __LINE__, Logger::INFO, fmt, ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure><p>其他宏如LOG_DEBUG,LOG_ERROR等原理类似，且按需包含函数名</p><h2 id="日志等级设置"><a href="#日志等级设置" class="headerlink" title="日志等级设置"></a>日志等级设置</h2><p>可以动态设置日志等级:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger::<span class="built_in">setLogLevel</span>(Logger::WARN);<span class="comment">//只显示WARN以上的日志</span></span><br></pre></td></tr></table></figure><p>日志等级是静态变量:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Logger::LogLevel g_logLevel=Logger::INFO;</span><br></pre></td></tr></table></figure><h2 id="自定义输出与刷新"><a href="#自定义输出与刷新" class="headerlink" title="自定义输出与刷新"></a>自定义输出与刷新</h2><p>可以通过函数指针实现对输出的灵活回调：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Logger::<span class="built_in">setOutput</span>([](<span class="type">const</span> <span class="type">char</span>*msg,<span class="type">int</span> len)</span><br><span class="line">                  &#123;<span class="built_in">fwrite</span>(msg,<span class="number">1</span>,len,stdout);&#125;);</span><br><span class="line"><span class="comment">//输出到终端</span></span><br></pre></td></tr></table></figure><p>也可以重定向输出到文件:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FILE*fp=<span class="built_in">fopen</span>(<span class="string">&quot;log.txt&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">Logger::<span class="built_in">setOutput</span>([fp](<span class="type">const</span> <span class="type">char</span>* msg,<span class="type">int</span> len)</span><br><span class="line">                  &#123;<span class="built_in">fwrite</span>(msg,<span class="number">1</span>,len,fp);&#125;);</span><br></pre></td></tr></table></figure><h2 id="添加日志颜色"><a href="#添加日志颜色" class="headerlink" title="添加日志颜色"></a>添加日志颜色</h2><p>更改levelNames[]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *levelNames[] = &#123;</span><br><span class="line">    <span class="string">&quot;TRACE&quot;</span>,</span><br><span class="line">    <span class="string">&quot;DEBUG&quot;</span>,</span><br><span class="line">    <span class="string">&quot;INFO&quot;</span>,</span><br><span class="line">    <span class="string">&quot;WARN&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ERROR&quot;</span>,</span><br><span class="line">    <span class="string">&quot;FATAL&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *levelNames[] = &#123;</span><br><span class="line">    <span class="string">&quot;\033[36mTRACE\033[0m&quot;</span>,</span><br><span class="line">    <span class="string">&quot;\033[34mDEBUG\033[0m&quot;</span> ,</span><br><span class="line">    <span class="string">&quot;\033[32mINFO\033[0m&quot;</span> ,</span><br><span class="line">    <span class="string">&quot;\033[33mWARN\033[0m&quot;</span>,</span><br><span class="line">    <span class="string">&quot;\033[31mERROR\033[0m&quot;</span>,</span><br><span class="line">    <span class="string">&quot;\033[35mFATAL\033[0m&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><p>如果输出到文件，也会写入颜色控制代码(就是那些<code>\033[32m</code>)，也会污染日志文件，可以通过条件判断是否加颜色 (比如<code>enableColorLog</code>)决定是否加颜色</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Logger.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOGGER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGGER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> mylib</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_TRACE(fmt, ...)                                \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (mylib::Logger::logLevel() &lt;= mylib::Logger::TRACE) \</span></span><br><span class="line"><span class="meta">    mylib::Logger::log(mylib::Logger::SourceFile(__FILE__), __LINE__, mylib::Logger::TRACE, __func__, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(fmt, ...)                                \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (mylib::Logger::logLevel() &lt;= mylib::Logger::DEBUG) \</span></span><br><span class="line"><span class="meta">    mylib::Logger::log(mylib::Logger::SourceFile(__FILE__), __LINE__, mylib::Logger::DEBUG, __func__, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(fmt, ...) \</span></span><br><span class="line"><span class="meta">    mylib::Logger::log(mylib::Logger::SourceFile(__FILE__), __LINE__, mylib::Logger::INFO, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARN(fmt, ...) \</span></span><br><span class="line"><span class="meta">    mylib::Logger::log(mylib::Logger::SourceFile(__FILE__), __LINE__, mylib::Logger::WARN, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(fmt, ...) \</span></span><br><span class="line"><span class="meta">    mylib::Logger::log(mylib::Logger::SourceFile(__FILE__), __LINE__, mylib::Logger::ERROR, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_FATAL(fmt, ...) \</span></span><br><span class="line"><span class="meta">    mylib::Logger::log(mylib::Logger::SourceFile(__FILE__), __LINE__, mylib::Logger::FATAL, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_SYSERR(fmt, ...) \</span></span><br><span class="line"><span class="meta">    mylib::Logger::logSys(mylib::Logger::SourceFile(__FILE__), __LINE__, false, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_SYSFATAL(fmt, ...) \</span></span><br><span class="line"><span class="meta">    mylib::Logger::logSys(mylib::Logger::SourceFile(__FILE__), __LINE__, true, fmt, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Logger</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">LogLevel</span></span><br><span class="line">        &#123;TRACE,DEBUG,INFO,WARN,ERROR,FATAL,NUM_LOG_LEVALS,&#125;;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">SourceFile</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *data_;</span><br><span class="line">            <span class="type">int</span> size_;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line">            <span class="built_in">SourceFile</span>(<span class="type">const</span> <span class="built_in">char</span> (&amp;arr)[N]) : <span class="built_in">data_</span>(arr), <span class="built_in">size_</span>(N - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> *slash = <span class="built_in">strrchr</span>(data_, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (slash)</span><br><span class="line">                &#123;</span><br><span class="line">                    data_ = slash + <span class="number">1</span>;</span><br><span class="line">                    size_ -= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(data_ - arr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">explicit</span> <span class="title">SourceFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename)</span> : data_(filename)</span></span><br><span class="line"><span class="function">            &#123;</span></span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> *slash = <span class="built_in">strrchr</span>(filename, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (slash)</span><br><span class="line">                &#123; data_ = slash + <span class="number">1</span>;&#125;</span><br><span class="line">                size_ = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">strlen</span>(data_));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(SourceFile file, <span class="type">int</span> line, LogLevel level, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">log</span><span class="params">(SourceFile file, <span class="type">int</span> line, LogLevel level, <span class="type">const</span> <span class="type">char</span> *func, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">logSys</span><span class="params">(SourceFile file, <span class="type">int</span> line, <span class="type">bool</span> fatal, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> LogLevel <span class="title">logLevel</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setLogLevel</span><span class="params">(LogLevel level)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*OutputFunc)</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg, <span class="type">int</span> len)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FlushFunc)</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setOutput</span><span class="params">(OutputFunc)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setFlush</span><span class="params">(FlushFunc)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">Logger</span>() = <span class="keyword">delete</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">extern</span> Logger::LogLevel g_logLevel;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">bool</span> showMicroseconds;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">bool</span> enableColorLog;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Logger.cc*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timestamp.h&quot;</span><span class="comment">//可以使用formatTime函数代替时间戳</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> mylib</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Logger::LogLevel g_logLevel = Logger::TRACE;</span><br><span class="line">    <span class="type">bool</span> showMicroseconds = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> enableColorLog = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::mutex g_mutex;</span><br><span class="line">    <span class="type">static</span> Logger::OutputFunc g_output = [](<span class="type">const</span> <span class="type">char</span> *msg, <span class="type">int</span> len)</span><br><span class="line">    &#123; <span class="built_in">fwrite</span>(msg, <span class="number">1</span>, len, stdout); &#125;;</span><br><span class="line">    <span class="type">static</span> Logger::FlushFunc g_flush = []()</span><br><span class="line">    &#123; <span class="built_in">fflush</span>(stdout); &#125;;</span><br><span class="line"></span><br><span class="line">    __thread <span class="type">char</span> t_errnobuf[<span class="number">512</span>];</span><br><span class="line">    __thread <span class="type">char</span> t_time[<span class="number">32</span>];</span><br><span class="line">    __thread <span class="type">time_t</span> t_lastSecond;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">strerror_tl</span><span class="params">(<span class="type">int</span> savedErrno)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strerror_r</span>(savedErrno, t_errnobuf, <span class="built_in">sizeof</span>(t_errnobuf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">formatTime</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (now != t_lastSecond)</span><br><span class="line">        &#123;</span><br><span class="line">            t_lastSecond = now;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">tm</span> tm_time;</span><br><span class="line">            <span class="built_in">gmtime_r</span>(&amp;now, &amp;tm_time);</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, size, <span class="string">&quot;%4d%02d%02d %02d:%02d:%02d&quot;</span>,</span><br><span class="line">                     tm_time.tm_year + <span class="number">1900</span>, tm_time.tm_mon + <span class="number">1</span>, tm_time.tm_mday,</span><br><span class="line">                     tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *levelNames[] = &#123;</span><br><span class="line">        mylib::enableColorLog ? <span class="string">&quot;\033[36mTRACE\033[0m&quot;</span> : <span class="string">&quot;TRACE&quot;</span>,</span><br><span class="line">        mylib::enableColorLog ? <span class="string">&quot;\033[34mDEBUG\033[0m&quot;</span> : <span class="string">&quot;DEBUG&quot;</span>,</span><br><span class="line">        mylib::enableColorLog ? <span class="string">&quot;\033[32mINFO\033[0m&quot;</span> : <span class="string">&quot;INFO&quot;</span>,</span><br><span class="line">        mylib::enableColorLog ? <span class="string">&quot;\033[33mWARN\033[0m&quot;</span> : <span class="string">&quot;WARN&quot;</span>,</span><br><span class="line">        mylib::enableColorLog ? <span class="string">&quot;\033[31mERROR\033[0m&quot;</span> : <span class="string">&quot;ERROR&quot;</span>,</span><br><span class="line">        mylib::enableColorLog ? <span class="string">&quot;\033[35mFATAL\033[0m&quot;</span> : <span class="string">&quot;FATAL&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Logger::log</span><span class="params">(SourceFile file, <span class="type">int</span> line, LogLevel level, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level &lt; g_logLevel)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        std::string time_buf;</span><br><span class="line">        Timestamp timestamp = Timestamp::<span class="built_in">now</span>();</span><br><span class="line">        time_buf = timestamp.<span class="built_in">toFormattedString</span>(showMicroseconds);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> msg_buf[<span class="number">1024</span>];</span><br><span class="line">        va_list args;</span><br><span class="line">        <span class="built_in">va_start</span>(args, fmt);</span><br><span class="line">        <span class="built_in">vsnprintf</span>(msg_buf, <span class="built_in">sizeof</span>(msg_buf), fmt, args);</span><br><span class="line">        <span class="built_in">va_end</span>(args);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> line_buf[<span class="number">2048</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(line_buf, <span class="built_in">sizeof</span>(line_buf), <span class="string">&quot;[%s][%s] %s:%d: %s\n&quot;</span>,</span><br><span class="line">                 time_buf.<span class="built_in">c_str</span>(), levelNames[level], file.data_, line, msg_buf);</span><br><span class="line"></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">        <span class="built_in">g_output</span>(line_buf, <span class="built_in">strlen</span>(line_buf));</span><br><span class="line">        <span class="built_in">g_flush</span>();</span><br><span class="line">        <span class="keyword">if</span> (level == FATAL)</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Logger::log</span><span class="params">(SourceFile file, <span class="type">int</span> line, LogLevel level, <span class="type">const</span> <span class="type">char</span> *func, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level &lt; g_logLevel)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        std::string time_buf;</span><br><span class="line">        Timestamp timestamp = Timestamp::<span class="built_in">now</span>();</span><br><span class="line">        time_buf = timestamp.<span class="built_in">toFormattedString</span>(showMicroseconds);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> msg_buf[<span class="number">1024</span>];</span><br><span class="line">        va_list args;</span><br><span class="line">        <span class="built_in">va_start</span>(args, fmt);</span><br><span class="line">        <span class="built_in">vsnprintf</span>(msg_buf, <span class="built_in">sizeof</span>(msg_buf), fmt, args);</span><br><span class="line">        <span class="built_in">va_end</span>(args);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> line_buf[<span class="number">2048</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(line_buf, <span class="built_in">sizeof</span>(line_buf), <span class="string">&quot;[%s][%s] %s %s:%d: %s\n&quot;</span>,</span><br><span class="line">                 time_buf.<span class="built_in">c_str</span>(), levelNames[level], func, file.data_, line, msg_buf);</span><br><span class="line"></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">        <span class="built_in">g_output</span>(line_buf, <span class="built_in">strlen</span>(line_buf));</span><br><span class="line">        <span class="built_in">g_flush</span>();</span><br><span class="line">        <span class="keyword">if</span> (level == FATAL)</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Logger::logSys</span><span class="params">(SourceFile file, <span class="type">int</span> line, <span class="type">bool</span> fatal, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> savedErrno = errno;</span><br><span class="line">        LogLevel level = fatal ? FATAL : ERROR;</span><br><span class="line">        <span class="keyword">if</span> (level &lt; g_logLevel)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        std::string time_buf;</span><br><span class="line">        Timestamp timestamp = Timestamp::<span class="built_in">now</span>();</span><br><span class="line">        time_buf = timestamp.<span class="built_in">toFormattedString</span>(showMicroseconds);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> msg_buf[<span class="number">1024</span>];</span><br><span class="line">        va_list args;</span><br><span class="line">        <span class="built_in">va_start</span>(args, fmt);</span><br><span class="line">        <span class="built_in">vsnprintf</span>(msg_buf, <span class="built_in">sizeof</span>(msg_buf), fmt, args);</span><br><span class="line">        <span class="built_in">va_end</span>(args);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> line_buf[<span class="number">2048</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(line_buf, <span class="built_in">sizeof</span>(line_buf), <span class="string">&quot;[%s][%s] %s:%d: %s (errno=%d: %s)\n&quot;</span>,</span><br><span class="line">                 time_buf.<span class="built_in">c_str</span>(), levelNames[level], file.data_, line, msg_buf, savedErrno, <span class="built_in">strerror_tl</span>(savedErrno));</span><br><span class="line"></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">        <span class="built_in">g_output</span>(line_buf, <span class="built_in">strlen</span>(line_buf));</span><br><span class="line">        <span class="built_in">g_flush</span>();</span><br><span class="line">        <span class="keyword">if</span> (fatal)</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Logger::LogLevel <span class="title">Logger::logLevel</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> g_logLevel; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Logger::setLogLevel</span><span class="params">(LogLevel level)</span> </span>&#123; g_logLevel = level; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Logger::setOutput</span><span class="params">(OutputFunc output)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">        g_output = output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Logger::setFlush</span><span class="params">(FlushFunc flush)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">        g_flush = flush;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;调用日志库有两种高效的方式，基本思路是全局定义宏：这里使用第二种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.使用operator&amp;lt;&amp;lt;重载，将log信息当作流，类似于cout&amp;lt;&amp;lt;&lt;/li&gt;
&lt;li&gt;2.使用函数调用，将log信息当作函数参数，类似于print()&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>解决github Connection closed by port 22</title>
    <link href="http://example.com/2025/04/14/%E8%A7%A3%E5%86%B3github-Connection-closed-by-port-22/"/>
    <id>http://example.com/2025/04/14/%E8%A7%A3%E5%86%B3github-Connection-closed-by-port-22/</id>
    <published>2025-04-14T09:26:23.000Z</published>
    <updated>2025-04-23T13:24:18.306Z</updated>
    
    <content type="html"><![CDATA[<p>最近china的防火墙升级，屏蔽了22端口。GitHub 支持通过 443 端口使用 SSH（因为 443 通常用于 HTTPS 流量，不易被屏蔽）。</p><h2 id="问题示例"><a href="#问题示例" class="headerlink" title="问题示例"></a>问题示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">test</span> git:(master) git push origin master</span><br><span class="line">Connection closed by 20.205.243.166 port 22</span><br><span class="line">fatal: 无法读取远程仓库。</span><br><span class="line"></span><br><span class="line">请确认您有正确的访问权限并且仓库存在。</span><br></pre></td></tr></table></figure><h1 id="配置SSH默认使用443端口"><a href="#配置SSH默认使用443端口" class="headerlink" title="配置SSH默认使用443端口"></a>配置SSH默认使用443端口</h1><h2 id="1-修改SSH配置文件"><a href="#1-修改SSH配置文件" class="headerlink" title="1.修改SSH配置文件"></a>1.修改SSH配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.ssh/config</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#添加以下内容</span><br><span class="line">Host github.com</span><br><span class="line">    Hostname ssh.github.com</span><br><span class="line">    Port 443</span><br><span class="line">    User git</span><br></pre></td></tr></table></figure><h2 id="2-设置文件权限"><a href="#2-设置文件权限" class="headerlink" title="2.设置文件权限"></a>2.设置文件权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 600 ~/.ssh/config</span><br></pre></td></tr></table></figure><h2 id="3-测试连接"><a href="#3-测试连接" class="headerlink" title="3.测试连接"></a>3.测试连接</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>可以看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi guy! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><p>这样就可以重新 <code>git push origin main/master</code>了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近china的防火墙升级，屏蔽了22端口。GitHub 支持通过 443 端口使用 SSH（因为 443 通常用于 HTTPS 流量，不易被屏蔽）。&lt;/p&gt;
&lt;h2 id=&quot;问题示例&quot;&gt;&lt;a href=&quot;#问题示例&quot; class=&quot;headerlink&quot; title=&quot;问</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>无代理下安装V2RayA(Debian/Ubuntu)</title>
    <link href="http://example.com/2025/04/14/%E6%97%A0%E4%BB%A3%E7%90%86%E4%B8%8B%E5%AE%89%E8%A3%85V2RayA(Debian-Ubuntu)/"/>
    <id>http://example.com/2025/04/14/%E6%97%A0%E4%BB%A3%E7%90%86%E4%B8%8B%E5%AE%89%E8%A3%85V2RayA(Debian-Ubuntu)/</id>
    <published>2025-04-14T03:23:53.000Z</published>
    <updated>2025-04-23T13:24:04.529Z</updated>
    
    <content type="html"><![CDATA[<p>阿安装v2ray的一般方法需要梯子，这几乎是个死循环，这里有两个不常见的方法</p><h1 id="方法一：通过软件源安装（推荐）"><a href="#方法一：通过软件源安装（推荐）" class="headerlink" title="方法一：通过软件源安装（推荐）"></a>方法一：通过软件源安装（推荐）</h1><h2 id="安全添加-V2RayA-软件源的-GPG-公钥"><a href="#安全添加-V2RayA-软件源的-GPG-公钥" class="headerlink" title="安全添加 V2RayA 软件源的 GPG 公钥"></a><strong>安全添加 V2RayA 软件源的 GPG 公钥</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https://apt.v2raya.org/key/public-key.asc | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/keyrings/v2raya.asc</span><br></pre></td></tr></table></figure><h2 id="添加V2RayA软件源"><a href="#添加V2RayA软件源" class="headerlink" title="添加V2RayA软件源"></a>添加V2RayA软件源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/etc/apt/keyrings/v2raya.asc] https://apt.v2raya.org/ v2raya main&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/v2raya.list</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br></pre></td></tr></table></figure><h2 id="安装V2RayA"><a href="#安装V2RayA" class="headerlink" title="安装V2RayA"></a>安装V2RayA</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install v2raya v2ray </span><br></pre></td></tr></table></figure><h2 id="启动v2rayA-自启动v2rayA"><a href="#启动v2rayA-自启动v2rayA" class="headerlink" title="启动v2rayA&#x2F;自启动v2rayA"></a>启动v2rayA&#x2F;自启动v2rayA</h2><ul><li><p>启动v2rayA</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start v2raya.service</span><br></pre></td></tr></table></figure></li><li><p>设置开机自启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> v2raya.service</span><br></pre></td></tr></table></figure></li></ul><h1 id="方法二：通过Snap包安装"><a href="#方法二：通过Snap包安装" class="headerlink" title="方法二：通过Snap包安装"></a>方法二：通过Snap包安装</h1><h2 id="安装Snap"><a href="#安装Snap" class="headerlink" title="安装Snap"></a>安装Snap</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install snapd</span><br></pre></td></tr></table></figure><h2 id="安装V2RayA-1"><a href="#安装V2RayA-1" class="headerlink" title="安装V2RayA"></a>安装V2RayA</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo snap install v2raya  #默认启动和自启动</span><br></pre></td></tr></table></figure><p>为什么不推荐snap 呢，因为snap安装的v2raya有时候有点bug</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;阿安装v2ray的一般方法需要梯子，这几乎是个死循环，这里有两个不常见的方法&lt;/p&gt;
&lt;h1 id=&quot;方法一：通过软件源安装（推荐）&quot;&gt;&lt;a href=&quot;#方法一：通过软件源安装（推荐）&quot; class=&quot;headerlink&quot; title=&quot;方法一：通过软件源安装（推荐）&quot;</summary>
      
    
    
    
    
  </entry>
  
</feed>
