[{"title":"C++实现日志库","date":"2025-04-19T03:50:17.000Z","path":"2025/04/19/C-实现日志库/","text":"调用日志库有两种高效的方式，基本思路是全局定义宏：这里使用第二种 1.使用operator&lt;&lt;重载，将log信息当作流，类似于cout&lt;&lt; 2.使用函数调用，将log信息当作函数参数，类似于print() 123456LOG_INFO&lt;&lt;&quot;服务器启动成功，端口：&quot;&lt;&lt;port;LOG_WARN&lt;&lt;&quot;连接超时:&quot;&lt;&lt;connId;LOG_ERROR&lt;&lt;&quot;数据库连接失败&quot;；LOG_INFO(&quot;服务器启动成功，端口：%d&quot;,port);LOG_WARN(&quot;连接超时: %d&quot;,connId);LOG_ERROR(&quot;数据库连接失败&quot;); 日志库功能日志库（Logging Library）是用于记录运行时信息的工具组件。 作为server唯一输出的内容，日志库显得尤为重要。 基本功能 日志级别 : 支持不同级别（如 DEBUG、INFO、WARN、ERROR、FATAL），方便控制输出粒度。 时间戳：每条日志通常包含精确的时间戳，帮助排查问题。 线程信息: 可选地记录线程 ID。 日志输出日志库可以将日志信息输出到不同的目标，包括： 终端输出：打印到终端或命令行界面，用于开发和调试。 文件输出：将日志写入文件中，持久存储在日志文件中。 网络输出：通过网络将日志发送到远程服务器或日志收集系统。 数据库：有些日志库允许将日志信息存储到数据库中。 输出示例1234[2025-03-14 03:40:27][TRACE] updateChannel Poller.cc:49: fd=3 events=3[2025-03-14 03:40:27][TRACE] EventLoop EventLoop.cc:16: EventLoop created 0x7ffd65bb0120 in thread 12521[2025-03-14 03:40:28][TRACE] poll Poller.cc:15: 1 events happended[2025-03-14 03:40:28][TRACE] readTimerfd TimerQueue.cc:60: TimerQueue::handleRead() reads 8 at 1745034028.327096 Logger类设计最基本的功能 log()，输出日志 123456789101112131415161718192021222324252627class Logger &#123; public: enum LogLevel &#123; TRACE, DEBUG, INFO, WARN, ERROR, FATAL, NUM_LOG_LEVALS, &#125;; static void log(SourceFile file, int line, LogLevel level, const char *fmt, ...); static void log(SourceFilefile, int line, LogLevel level, const char *func, const char *fmt...); static void logSys(SourceFile file, int line, bool fatal, const char *fmt, ...); static LogLevel logLevel();//设置日当前志级别 static void setLogLevel(LogLevel level); typedef void (*OutputFunc)(const char *msg, int len); typedef void (*FlushFunc)(); static void setOutput(OutputFunc);//设置输出方式，自定义回调如输出到终端或者输出到文件 static void setFlush(FlushFunc);//设置刷新缓冲方式 private: Logger() = delete;//不允许实例化Logger类 &#125;; 配置的SouceFIle是一个小工具类，用于从__FILE__中提取文件名，避免日志中出现过长的路径 1234567891011class SourceFile&#123;public: const char *data_; int size_; template &lt;int N&gt; SourceFile(const char (&amp;arr)[N]) : data_(arr), size_(N - 1); explicit SourceFile(const char *filename) : data_(filename);&#125;; 日志输出逻辑我们重点实现的格式化日志调用方式是这样的: 1Logger::log(__FILE__,__LINE__,Logger::INFO,fmt,...); 实现代码核心逻辑如下1234567891011121314static void formatTime(char *buf, size_t size)&#123; time_t now = time(nullptr); if (now != t_lastSecond) &#123; t_lastSecond = now; struct tm tm_time; gmtime_r(&amp;now, &amp;tm_time); snprintf(buf, size, &quot;%4d%02d%02d %02d:%02d:%02d&quot;, tm_time.tm_year + 1900, tm_time.tm_mon + 1, tm_time.tm_mday, tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec); &#125;&#125; 123456789101112131415161718192021222324252627282930313233void Logger::log(SourceFile file, int line, LogLevel level, const char *fmt, ...) &#123; if (level &lt; g_logLevel) return; std::string time_buf; Timestamp timestamp = Timestamp::now(); time_buf = timestamp.toFormattedString(showMicroseconds); /*初始化时间也可: char timebuf[64]; formatTime(buf,sizeof(buf)); 这里使用时间戳类避免再次实现*/ //格式化用户传入的消息 char msg_buf[1024]; va_list args; va_start(args, fmt); vsnprintf(msg_buf, sizeof(msg_buf), fmt, args); va_end(args); //拼接最终输出内容 char line_buf[2048]; snprintf(line_buf, sizeof(line_buf), &quot;[%s][%s] %s:%d: %s\\n&quot;, time_buf.c_str(), levelNames[level], file.data_, line, msg_buf); //加锁输出日志 std::lock_guard&lt;std::mutex&gt; lock(g_mutex); g_output(line_buf, strlen(line_buf)); g_flush(); //如果是FATAL级别，终止程序 if (level == FATAL) abort(); &#125; 日志宏封装使用宏是为了让调用更简洁，自动传入__FILE__和__LINE__,日志级别等元信息: 12#define LOG_INFO(fmt, ...) \\ Logger::log(Logger::SourceFile(__FILE__), __LINE__, Logger::INFO, fmt, ##__VA_ARGS__) 其他宏如LOG_DEBUG,LOG_ERROR等原理类似，且按需包含函数名 日志等级设置可以动态设置日志等级: 1Logger::setLogLevel(Logger::WARN);//只显示WARN以上的日志 日志等级是静态变量: 1static Logger::LogLevel g_logLevel=Logger::INFO; 自定义输出与刷新可以通过函数指针实现对输出的灵活回调： 123Logger::setOutput([](const char*msg,int len) &#123;fwrite(msg,1,len,stdout);&#125;);//输出到终端 也可以重定向输出到文件: 123FILE*fp=fopen(&quot;log.txt&quot;,&quot;a&quot;);Logger::setOutput([fp](const char* msg,int len) &#123;fwrite(msg,1,len,fp);&#125;); 添加日志颜色更改levelNames[] 123456789static const char *levelNames[] = &#123; &quot;TRACE&quot;, &quot;DEBUG&quot;, &quot;INFO&quot;, &quot;WARN&quot;, &quot;ERROR&quot;, &quot;FATAL&quot;,&#125;; 为 12345678static const char *levelNames[] = &#123; &quot;\\033[36mTRACE\\033[0m&quot;, &quot;\\033[34mDEBUG\\033[0m&quot; , &quot;\\033[32mINFO\\033[0m&quot; , &quot;\\033[33mWARN\\033[0m&quot;, &quot;\\033[31mERROR\\033[0m&quot;, &quot;\\033[35mFATAL\\033[0m&quot;,&#125;; **注意事项 ** 如果输出到文件，也会写入颜色控制代码(就是那些\\033[32m)，也会污染日志文件，可以通过条件判断是否加颜色 (比如enableColorLog)决定是否加颜色 源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/*Logger.h*/#ifndef LOGGER_H#define LOGGER_H#include &lt;cstring&gt;namespace mylib&#123;#define LOG_TRACE(fmt, ...) \\ if (mylib::Logger::logLevel() &lt;= mylib::Logger::TRACE) \\ mylib::Logger::log(mylib::Logger::SourceFile(__FILE__), __LINE__, mylib::Logger::TRACE, __func__, fmt, ##__VA_ARGS__)#define LOG_DEBUG(fmt, ...) \\ if (mylib::Logger::logLevel() &lt;= mylib::Logger::DEBUG) \\ mylib::Logger::log(mylib::Logger::SourceFile(__FILE__), __LINE__, mylib::Logger::DEBUG, __func__, fmt, ##__VA_ARGS__)#define LOG_INFO(fmt, ...) \\ mylib::Logger::log(mylib::Logger::SourceFile(__FILE__), __LINE__, mylib::Logger::INFO, fmt, ##__VA_ARGS__)#define LOG_WARN(fmt, ...) \\ mylib::Logger::log(mylib::Logger::SourceFile(__FILE__), __LINE__, mylib::Logger::WARN, fmt, ##__VA_ARGS__)#define LOG_ERROR(fmt, ...) \\ mylib::Logger::log(mylib::Logger::SourceFile(__FILE__), __LINE__, mylib::Logger::ERROR, fmt, ##__VA_ARGS__)#define LOG_FATAL(fmt, ...) \\ mylib::Logger::log(mylib::Logger::SourceFile(__FILE__), __LINE__, mylib::Logger::FATAL, fmt, ##__VA_ARGS__)#define LOG_SYSERR(fmt, ...) \\ mylib::Logger::logSys(mylib::Logger::SourceFile(__FILE__), __LINE__, false, fmt, ##__VA_ARGS__)#define LOG_SYSFATAL(fmt, ...) \\ mylib::Logger::logSys(mylib::Logger::SourceFile(__FILE__), __LINE__, true, fmt, ##__VA_ARGS__) class Logger &#123; public: enum LogLevel &#123; TRACE,DEBUG,INFO,WARN,ERROR,FATAL,NUM_LOG_LEVALS,&#125;; class SourceFile &#123; public: const char *data_; int size_; template &lt;int N&gt; SourceFile(const char (&amp;arr)[N]) : data_(arr), size_(N - 1) &#123; const char *slash = strrchr(data_, &#x27;/&#x27;); if (slash) &#123; data_ = slash + 1; size_ -= static_cast&lt;int&gt;(data_ - arr); &#125; &#125; explicit SourceFile(const char *filename) : data_(filename) &#123; const char *slash = strrchr(filename, &#x27;/&#x27;); if (slash) &#123; data_ = slash + 1;&#125; size_ = static_cast&lt;int&gt;(strlen(data_)); &#125; &#125;; static void log(SourceFile file, int line, LogLevel level, const char *fmt, ...); static void log(SourceFile file, int line, LogLevel level, const char *func, const char *fmt, ...); static void logSys(SourceFile file, int line, bool fatal, const char *fmt, ...); static LogLevel logLevel(); static void setLogLevel(LogLevel level); typedef void (*OutputFunc)(const char *msg, int len); typedef void (*FlushFunc)(); static void setOutput(OutputFunc); static void setFlush(FlushFunc); private: Logger() = delete; &#125;; extern Logger::LogLevel g_logLevel; extern bool showMicroseconds; extern bool enableColorLog;&#125;;#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150/*Logger.cc*/#include &quot;Logger.h&quot;#include &quot;Timestamp.h&quot;//可以使用formatTime函数代替时间戳#include &lt;mutex&gt;#include &lt;thread&gt;#include &lt;cstdarg&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;namespace mylib&#123; Logger::LogLevel g_logLevel = Logger::TRACE; bool showMicroseconds = false; bool enableColorLog = true; static std::mutex g_mutex; static Logger::OutputFunc g_output = [](const char *msg, int len) &#123; fwrite(msg, 1, len, stdout); &#125;; static Logger::FlushFunc g_flush = []() &#123; fflush(stdout); &#125;; __thread char t_errnobuf[512]; __thread char t_time[32]; __thread time_t t_lastSecond; const char *strerror_tl(int savedErrno) &#123; return strerror_r(savedErrno, t_errnobuf, sizeof(t_errnobuf)); &#125; static void formatTime(char *buf, size_t size) &#123; time_t now = time(nullptr); if (now != t_lastSecond) &#123; t_lastSecond = now; struct tm tm_time; gmtime_r(&amp;now, &amp;tm_time); snprintf(buf, size, &quot;%4d%02d%02d %02d:%02d:%02d&quot;, tm_time.tm_year + 1900, tm_time.tm_mon + 1, tm_time.tm_mday, tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec); &#125; &#125; static const char *levelNames[] = &#123; mylib::enableColorLog ? &quot;\\033[36mTRACE\\033[0m&quot; : &quot;TRACE&quot;, mylib::enableColorLog ? &quot;\\033[34mDEBUG\\033[0m&quot; : &quot;DEBUG&quot;, mylib::enableColorLog ? &quot;\\033[32mINFO\\033[0m&quot; : &quot;INFO&quot;, mylib::enableColorLog ? &quot;\\033[33mWARN\\033[0m&quot; : &quot;WARN&quot;, mylib::enableColorLog ? &quot;\\033[31mERROR\\033[0m&quot; : &quot;ERROR&quot;, mylib::enableColorLog ? &quot;\\033[35mFATAL\\033[0m&quot; : &quot;FATAL&quot;, &#125;; void Logger::log(SourceFile file, int line, LogLevel level, const char *fmt, ...) &#123; if (level &lt; g_logLevel) return; std::string time_buf; Timestamp timestamp = Timestamp::now(); time_buf = timestamp.toFormattedString(showMicroseconds); char msg_buf[1024]; va_list args; va_start(args, fmt); vsnprintf(msg_buf, sizeof(msg_buf), fmt, args); va_end(args); char line_buf[2048]; snprintf(line_buf, sizeof(line_buf), &quot;[%s][%s] %s:%d: %s\\n&quot;, time_buf.c_str(), levelNames[level], file.data_, line, msg_buf); std::lock_guard&lt;std::mutex&gt; lock(g_mutex); g_output(line_buf, strlen(line_buf)); g_flush(); if (level == FATAL) abort(); &#125; void Logger::log(SourceFile file, int line, LogLevel level, const char *func, const char *fmt, ...) &#123; if (level &lt; g_logLevel) return; std::string time_buf; Timestamp timestamp = Timestamp::now(); time_buf = timestamp.toFormattedString(showMicroseconds); char msg_buf[1024]; va_list args; va_start(args, fmt); vsnprintf(msg_buf, sizeof(msg_buf), fmt, args); va_end(args); char line_buf[2048]; snprintf(line_buf, sizeof(line_buf), &quot;[%s][%s] %s %s:%d: %s\\n&quot;, time_buf.c_str(), levelNames[level], func, file.data_, line, msg_buf); std::lock_guard&lt;std::mutex&gt; lock(g_mutex); g_output(line_buf, strlen(line_buf)); g_flush(); if (level == FATAL) abort(); &#125; void Logger::logSys(SourceFile file, int line, bool fatal, const char *fmt, ...) &#123; int savedErrno = errno; LogLevel level = fatal ? FATAL : ERROR; if (level &lt; g_logLevel) return; std::string time_buf; Timestamp timestamp = Timestamp::now(); time_buf = timestamp.toFormattedString(showMicroseconds); char msg_buf[1024]; va_list args; va_start(args, fmt); vsnprintf(msg_buf, sizeof(msg_buf), fmt, args); va_end(args); char line_buf[2048]; snprintf(line_buf, sizeof(line_buf), &quot;[%s][%s] %s:%d: %s (errno=%d: %s)\\n&quot;, time_buf.c_str(), levelNames[level], file.data_, line, msg_buf, savedErrno, strerror_tl(savedErrno)); std::lock_guard&lt;std::mutex&gt; lock(g_mutex); g_output(line_buf, strlen(line_buf)); g_flush(); if (fatal) abort(); &#125; Logger::LogLevel Logger::logLevel() &#123; return g_logLevel; &#125; void Logger::setLogLevel(LogLevel level) &#123; g_logLevel = level; &#125; void Logger::setOutput(OutputFunc output) &#123; std::lock_guard&lt;std::mutex&gt; lock(g_mutex); g_output = output; &#125; void Logger::setFlush(FlushFunc flush) &#123; std::lock_guard&lt;std::mutex&gt; lock(g_mutex); g_flush = flush; &#125;&#125;;"},{"title":"解决github Connection closed by port 22","date":"2025-04-14T09:26:23.000Z","path":"2025/04/14/解决github-Connection-closed-by-port-22/","text":"最近防火墙升级，屏蔽了22端口。GitHub 支持通过 443 端口使用 SSH（因为 443 通常用于 HTTPS 流量，不易被屏蔽）。 问题示例12345➜ test git:(master) git push origin masterConnection closed by 20.205.243.166 port 22fatal: 无法读取远程仓库。请确认您有正确的访问权限并且仓库存在。 配置SSH默认使用443端口1.修改SSH配置文件1vim ~/.ssh/config 12345#添加以下内容Host github.com Hostname ssh.github.com Port 443 User git 2.设置文件权限1chmod 600 ~/.ssh/config 3.测试连接1ssh -T git@github.com 可以看到 1Hi guy! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 这样就可以重新 git push origin main/master了"},{"title":"无代理下安装V2RayA(Debian/Ubuntu)","date":"2025-04-14T03:23:53.000Z","path":"2025/04/14/无代理下安装V2RayA-Debian-Ubuntu/","text":"方法一：通过软件源安装（推荐）安全添加 V2RayA 软件源的 GPG 公钥1wget -qO - https://apt.v2raya.org/key/public-key.asc | sudo tee /etc/apt/keyrings/v2raya.asc 添加V2RayA软件源12echo &quot;deb [signed-by=/etc/apt/keyrings/v2raya.asc] https://apt.v2raya.org/ v2raya main&quot; | sudo tee /etc/apt/sources.list.d/v2raya.listsudo apt update 安装V2RayA1sudo apt install v2raya v2ray 启动v2rayA&#x2F;自启动v2rayA 启动v2rayA 1sudo systemctl start v2raya.service 设置开机自启动 1sudo systemctl enable v2raya.service 方法二：通过Snap包安装安装Snap12sudo apt updatesudo apt install snapd 安装V2RayA1sudo snap install v2raya #默认启动和自启动"}]